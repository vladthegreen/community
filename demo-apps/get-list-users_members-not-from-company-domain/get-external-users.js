/**
 * @license
 * Copyright 2022 Thought Stream, LLC dba Bluescape
 * Permission is hereby granted, free of charge, to any person obtaining a copy 
 * of this software and associated documentation files (the "Software"), 
 * to deal in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, 
 * and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, 
 * subject to the following conditions:
 * 
 * The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, 
 * INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, 
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS 
 * OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, 
 * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, 
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 * 
 */
/**
 * Node.js Javascript
 * Purpose:
 *      Lists all users in an instance whose email domain does not match the
 *      domain specified. This is intended to assist in identifying users who
 *      are external to the organization. The list can be generated in either
 *      CSV or JSON format.
 * 
 * Requirements:
 *      To install all the required libraries, run 'npm install' in both this folder
 *      and the ../bluescape-modules folder.
 * 
 * Usage:
 *      node get-external-users --token=<token> --emailDomain=<email domain> --outputTo=<path/file name to write to>
 *                              [--filterBy=<ORG | WORKSPACE>]
 *                              [--filterById=<Id of organization or workspace>]
 *                              [--outputFormat=<CSV | JSON>]
 * 
 * Notes:
 *      To run this app against the entire instance requires that the token be
 *      generated by a user with Instance Admin privileges. A regular user can
 *      run the app when limiting the search to an Organization or Workspace,
 *      provided they can supply the necessary Id value.
 * 
 *      To obtain a token you can follow the instructions in the Application
 *      Authorization Guide found in the Developer Portal:
 *          https://api.apps.us.bluescape.com/docs/page/app-auth
 * 
 *      The outputFormat parameter will default to CSV if not specified.
 * 
 *      The optional "filterBy" argument accepts either of two values:
 *          - ORG : identifies external members within an Organization
 *          - WORKSPACE : identifies external collaborators within a Workspace
 * 
 *      Including the optional "filterBy" argument requires the "filterById" to
 *      also be specified with either the Id of the Organization or Workspace,
 *      as appropriate.
 * 
 *      The OrganizationId can be obtained from a simple GraphQL query:
 * 
 *          query getOrganizationsByName {
 *              organizations ( filtering: { name: { eq: "My Organization" } }) {
 *                  results {
 *                      id
 *                      name
 *                      secondaryName
 *                  }
 *              }
 *          }
 *
 *      The Workspace Id can be obtained from the URL displayed in the browser.
 *      When you open a workspace the Id is the first value following the domain.
 *      For example, this URL includes the Workspace Id "bbKg00aNOelot2SkYno0":
 * 
 *          https://client.apps.us.bluescape.com/bbKg00aNOelot2SkYno0
 */

import csvWriter from "csv-write-stream";
import { once } from 'events';
import fs from 'fs';
import { performance } from "perf_hooks";
import { stdout } from "process";
import Yargs from "yargs";
import { getExternalUsers } from "./external-user-service.js";

// App Parameters
const apiPortalUrl = 'https://api.apps.us.bluescape.com'; // Change this to match your environment, if necessary
const apiVersion = 'v3';

const args = Yargs(process.argv.slice(2)).argv;
const token = args.token ?? "<SET_TOKEN>";
let emailDomain = args.emailDomain ?? "<SET_EMAIL_DOMAIN>";
const outputTo = args.outputTo ?? "<SET_PATH_AND_NAME_OF_FILE>";
const outputFormat = args.outputFormat?.toUpperCase() ?? "CSV";
const filterBy = args.filterBy?.toUpperCase();
const filterById = args.filterById;

// Object to store the parameters for Bluescape API execution 
const bluescapeApiParams = {
    'token': token,
    'apiPortalUrl': apiPortalUrl,
    'apiVersion': apiVersion
};

/**
 * Main Function
 * Retrieves all users in the instance, organization, or workspace whose email
 * domain does not match the domain specified.
 */
async function runListExternalUsers() {

    const start = performance.now();
    const writer = await createFileWriter();

    try {
        validateMandatoryArgs();

        if (!stdout.write("Retrieving data..")) {
            await once(stdout, "drain");
        }
    
        if (!emailDomain.startsWith("@")) {
            emailDomain = "@" + emailDomain;
        }

        let cursor = null;

        // Loop until no more user data is available
        while (true) {
            // Provide visual feedback to user that something is happening
            if (!stdout.write(".")) {
                await once(stdout, "drain");
            }

            const results = await getExternalUsers(bluescapeApiParams, emailDomain, filterBy, filterById, cursor);
            await writeResults(writer, results, cursor == null);

            // If more data exists, get the cursor for the next page of data
            if (results.cursor) {
                cursor = results.cursor;
            }
            else {
                break;
            }
        }
    }
    catch (error) {
        const buildErrorMessage = (e) => 
            `${e?.message ?? e} ${e?.extensions?.statusCode ? "(Status code: " + e.extensions.statusCode + ")" : ""}`;

        if (Array.isArray(error)) {
            console.error(`${error.length == 1 ? "An error" : "Errors"} occurred while processing:`);
            for (const err of error) {
                console.error(buildErrorMessage(err));
            }
        }
        else {
            console.error(`An error occurred while processing: ${buildErrorMessage(error)}`);
        }
    }
    finally {
        await closeFileWriter(writer);
    }

    const end = performance.now()
    console.log(`\nProcess complete. (${Math.round((end - start)/1000)} seconds)`);
}

/**
 * Validates that mandatory arguments were supplied.
 */
function validateMandatoryArgs() {
    if (!token || token === "<SET_TOKEN>") {
        throw new ReferenceError("The token argument is required.");
    }

    if (!emailDomain || emailDomain === "<SET_EMAIL_DOMAIN") {
        throw new ReferenceError("The emailDomain argument is required.");
    }

    if (filterBy && !filterById) {
        throw new ReferenceError("The filterById argument must be supplied when the filterBy argument is supplied.");
    }

    if (!filterBy && filterById) {
        throw new ReferenceError("The filterBy argument must be supplied when the filterById argument is supplied.");
    }
}

/**
 * Creates and returns a file writer appropriate to the specified output format.
 * @returns A file writer.
 */
async function createFileWriter() {
    const stream = fs.createWriteStream(outputTo);

    if (outputFormat === "CSV") {
        const writer = csvWriter({ headers: ["Email", "FirstName", "LastName", "InvitationStatus"]});
        writer.pipe(stream);
        return writer;
    }
    else if (outputFormat === "JSON") {
        if (!stream.write("[")) {
            await once(stream, "drain");
        }

        return stream;
    }
    else {
        throw new ReferenceError("Invalid outputFormat specified.");
    }
}

/**
 * Closes the supplied file writer.
 * @param {*} writer The writer to close.
 */
async function closeFileWriter(writer) {
    if (outputFormat === "JSON") {
        if (!writer.write("]")) {
            await once(writer, "drain");
        }
    }

    writer.end();
}

/**
 * Writes the supplied results to the file.
 * @param {*} writer The writer to use.
 * @param {*} results The results to write.
 * @param {*} first Boolean flag to indicate if this is the first set of results being written.
 */
async function writeResults(writer, results, first) {

    for (const user of results.users) {
        if (outputFormat === "CSV") {
            writeUserCsv(writer, user);
        }
        else if (outputFormat === "JSON") {
            await writeUserJson(writer, user, first);
        }
        else {
            throw new ReferenceError("Invalid outputFormat specified.");
        }

        first = false;
    }
}

/**
 * Writes the supplied user to the file in CSV format.
 * @param {*} writer The writer to use.
 * @param {*} user The user to write.
 */
function writeUserCsv(writer, user) {
    writer.write([user.email, user.firstName, user.lastName, user.invitationStatus]);
}

/**
 * Writes the supplied user to the file in JSON format.
 * @param {*} writer The writer to use.
 * @param {*} user The user to write.
 * @param {*} first Boolean flag to indicate if this is the first user being written.
 */
async function writeUserJson(writer, user, first) {
    const data = (first ? "" : ", ") + JSON.stringify(user);
    if (!writer.write(data)) {
        await once(writer, "drain");
    }
}

/**
 * Creates and returns a file writer appropriate to the specified output format.
 * @returns A file writer.
 */
async function createFileWriter() {
    const stream = fs.createWriteStream(outputTo);

    if (outputFormat === "CSV") {
        const writer = csvWriter({ headers: ["Email", "FirstName", "LastName", "InvitationStatus"]});
        writer.pipe(stream);
        return writer;
    }
    else if (outputFormat === "JSON") {
        if (!stream.write("[")) {
            await once(stream, "drain");
        }

        return stream;
    }
    else {
        throw new ReferenceError("Invalid outputFormat specified.");
    }
}

/**
 * Closes the supplied file writer.
 * @param {*} writer The writer to close.
 */
async function closeFileWriter(writer) {
    if (outputFormat === "JSON") {
        if (!writer.write("]")) {
            await once(writer, "drain");
        }
    }

    writer.end();
}

/**
 * Writes the supplied results to the file.
 * @param {*} writer The writer to use.
 * @param {*} results The results to write.
 * @param {*} first Boolean flag to indicate if this is the first set of results being written.
 */
async function writeResults(writer, results, first) {

    for (const user of results.users) {
        if (outputFormat === "CSV") {
            writeUserCsv(writer, user);
        }
        else if (outputFormat === "JSON") {
            await writeUserJson(writer, user, first);
        }
        else {
            throw new ReferenceError("Invalid outputFormat specified.");
        }

        first = false;
    }
}

/**
 * Writes the supplied user to the file in CSV format.
 * @param {*} writer The writer to use.
 * @param {*} user The user to write.
 */
function writeUserCsv(writer, user) {
    writer.write([user.email, user.firstName, user.lastName, user.invitationStatus]);
}

/**
 * Writes the supplied user to the file in JSON format.
 * @param {*} writer The writer to use.
 * @param {*} user The user to write.
 * @param {*} first Boolean flag to indicate if this is the first user being written.
 */
async function writeUserJson(writer, user, first) {
    const data = (first ? "" : ", ") + JSON.stringify(user);
    if (!writer.write(data)) {
        await once(writer, "drain");
    }
}

// Run the app
runListExternalUsers();
